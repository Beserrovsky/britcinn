//
// Copyright 2020-2022 Picovoice Inc.
//
// You may not use this file except in compliance with the license. A copy of the license is located in the "LICENSE"
// file accompanying this source.
//
// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
// an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pvStatusToException = exports.PicovoiceActivationRefused = exports.PicovoiceActivationThrottled = exports.PicovoiceActivationLimitReached = exports.PicovoiceActivationError = exports.PicovoiceRuntimeError = exports.PicovoiceInvalidStateError = exports.PicovoiceKeyError = exports.PicovoiceStopIterationError = exports.PicovoiceInvalidArgumentError = exports.PicovoiceIoError = exports.PicovoiceOutOfMemoryError = exports.PicovoiceError = void 0;
const pv_status_t_1 = require("./pv_status_t");
class PicovoiceError extends Error {
}
exports.PicovoiceError = PicovoiceError;
class PicovoiceOutOfMemoryError extends PicovoiceError {
}
exports.PicovoiceOutOfMemoryError = PicovoiceOutOfMemoryError;
class PicovoiceIoError extends PicovoiceError {
}
exports.PicovoiceIoError = PicovoiceIoError;
class PicovoiceInvalidArgumentError extends PicovoiceError {
}
exports.PicovoiceInvalidArgumentError = PicovoiceInvalidArgumentError;
class PicovoiceStopIterationError extends PicovoiceError {
}
exports.PicovoiceStopIterationError = PicovoiceStopIterationError;
class PicovoiceKeyError extends PicovoiceError {
}
exports.PicovoiceKeyError = PicovoiceKeyError;
class PicovoiceInvalidStateError extends PicovoiceError {
}
exports.PicovoiceInvalidStateError = PicovoiceInvalidStateError;
class PicovoiceRuntimeError extends PicovoiceError {
}
exports.PicovoiceRuntimeError = PicovoiceRuntimeError;
class PicovoiceActivationError extends PicovoiceError {
}
exports.PicovoiceActivationError = PicovoiceActivationError;
class PicovoiceActivationLimitReached extends PicovoiceError {
}
exports.PicovoiceActivationLimitReached = PicovoiceActivationLimitReached;
class PicovoiceActivationThrottled extends PicovoiceError {
}
exports.PicovoiceActivationThrottled = PicovoiceActivationThrottled;
class PicovoiceActivationRefused extends PicovoiceError {
}
exports.PicovoiceActivationRefused = PicovoiceActivationRefused;
function pvStatusToException(pvStatus, errorMessage) {
    switch (pvStatus) {
        case pv_status_t_1.default.OUT_OF_MEMORY:
            throw new PicovoiceOutOfMemoryError(errorMessage);
        case pv_status_t_1.default.IO_ERROR:
            throw new PicovoiceIoError(errorMessage);
        case pv_status_t_1.default.INVALID_ARGUMENT:
            throw new PicovoiceInvalidArgumentError(errorMessage);
        case pv_status_t_1.default.STOP_ITERATION:
            throw new PicovoiceStopIterationError(errorMessage);
        case pv_status_t_1.default.KEY_ERROR:
            throw new PicovoiceKeyError(errorMessage);
        case pv_status_t_1.default.INVALID_STATE:
            throw new PicovoiceInvalidStateError(errorMessage);
        case pv_status_t_1.default.RUNTIME_ERROR:
            throw new PicovoiceRuntimeError(errorMessage);
        case pv_status_t_1.default.ACTIVATION_ERROR:
            throw new PicovoiceActivationError(errorMessage);
        case pv_status_t_1.default.ACTIVATION_LIMIT_REACHED:
            throw new PicovoiceActivationLimitReached(errorMessage);
        case pv_status_t_1.default.ACTIVATION_THROTTLED:
            throw new PicovoiceActivationThrottled(errorMessage);
        case pv_status_t_1.default.ACTIVATION_REFUSED:
            throw new PicovoiceActivationRefused(errorMessage);
        default:
            console.warn(`Unmapped error code: ${pvStatus}`);
            throw new PicovoiceError(errorMessage);
    }
}
exports.pvStatusToException = pvStatusToException;
//# sourceMappingURL=errors.js.map